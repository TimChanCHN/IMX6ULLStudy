# 2 C语言编程实验
## 1. 实验目的
    通过该实验，了解在imx6ull中，如何利用汇编文件、c文件、makefile来构建一个C语言项目。同时还可以利用链接脚本，来简化项目编写流程。代码是以led闪烁实验。

## 2. 代码编写
1. 启动引导代码start.s编写
   1. 具体代码见`led_c`文件夹
   2. 该代码的关键是设置寄存器cpsr为SVC模式，同时设置好堆栈指针SP，堆栈指针设置不好的话，可能会令其跳出内存地址
2. 源代码编写
   1. 具体代码见`led_c`文件夹
3. Makefile编写
   1. 该工程同时包含了汇编代码和C代码，而在程序执行的过程中，必须先执行start.s，因此在makefile中，必须要先令start.s编译，可以通过查看反汇编文件.dis中，start.s是否首先执行，否则肯定有问题
   2. 在makefile中的`%.o:%.s`，如果添加了选项-O2,有可能导致在反汇编文件中，start.s并不是在链接地址上，需要删除该选项。
4. 链接脚本
   1. 见该例子
   ```
    SECTIONS{
        . = 0x87800000;                 # . 和 = 之间要有空格
        .text :                         # .text 和 ：之间要有空格
        {   
            start.o                     # start.o放前面，意味着start.o先编译
            *(.text)                    # *(.text)工程的剩下代码
        }
        .rodata ALIGN(4) : {*(.rodata*)}
        .data ALIGN(4) : {*(.data)}
        __bss_start=.;
        .bss ALIGN(4) : {*(.bss) *(COMMON)}
        __bss_end=.;
    }
   ```
   2. 在链接脚本中, 符号`.`是指定位计数器，指定在内存中的特定位置；在连接脚本中，.以及其后面的字串需要与=/:之间有空格；
   3. 在Makefile需要用到链接脚本的话，则需要把选项`-Ttext`改为`-Tfilename`.
   4. __bss_start/__bss_end在uboot/kernel中经常使用，可以用于计算bss段大小
   5. 链接脚本需要以.lds为后缀

## 3.优化
1. 借用官方SDK库
   1. 如main.h中所示，每一个寄存器都赋值一个地址值，这样操作太麻烦了，使用的外设一多，代码就显得非常复杂并且不利于查看。
   2. 可以利用STM32官方SDK对寄存器的管理方法。对于每一类寄存器，均用一个结构体管理，把该类寄存器的首地址赋值给对应的结构体指针，便可以对该类结构体内部所有寄存器进行访问。
   3. 需要注意的是，如果芯片参考手册中，相邻两个寄存器地址相隔地址大于4个字节的时候，需要添加reserved变量填充，使得地址连续，这样才可以准确访问到对应的寄存器。
2. 使用BSP工程管理
   1. BSP工程管理是指把各个模块的代码放到不同的文件夹中，以便于管理。
   2. BSP文件夹用于存放对应模块代码以及芯片头文件(imx6ull相关寄存器设置)、OBJ文件夹用于存放编译产生的过程文件(如.o, .elf, .bin, .dis等)、PROJECT用于存放项目文件(start.s, main.c).
   3. 由于涉及了多个文件夹的内容，因此需要利用Makefile把这些部分的代码关联起来，整个工程管理核心就是利用Makefile把所有模块代码联系起来。

## 附录：Makefile进阶用法
1. 常用函数
   1. $(patsubst <pattern>, <replacement>, <text>)
   > 在text中，把符合pattern的内容替换成replacement

    2. $(subst <from>,<to>,<text>)
    > 把字串<text>中的<from>字符串替换成<to>

    3. $(foreach <var>,<list>,<text>)
    > 把参数<list>中的单词逐一取出放到参数<var>所指定的变量中,然后再执行<text>所包含的表达式

    4. $(notdir <names...>)
    > 从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠("/")之后的部分。

    5. 静态模式：<targets ...>: <target-pattern>: <prereq-patterns ...>
    > 参数1是目标集，参数2是由参数1引申出来的目标集合，参数3则是参数2的依赖。加入静态模式，使得当工程文件过多时，可以直接在targets后面添加文件名称即可。

2. 关键字
   1. wildcard:在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。因此需要增加该关键字使其生效。
   2. .PHONY：声明后面的是伪目标，如果Makefile目录下，有个可执行文件和伪目标名称相同，如果不加.PHONY,则会出现拒绝执行目标的情况。
   