# 2顶层Makefile分析
## 1.目的
1. 分析uboot的Makefile，有利于了解整个Uboot的工程结构。

## 2.相关变量介绍
1. 版本号
```Makefile 
#Uboot-2016.03
VERSION = 2016
PATCHLEVEL = 03
SUBLEVEL =
EXTRAVERSION =
NAME =
```
2. MAKEFLAGS变量    
   1. makefile支持递归调用，通过代码`$(MAKE) -C subdir`可以对子目录`subdir`进行编译。
   2. 如果需要把变量传递给子makefile时，通过export声明变量，`export VARIABLE...`，而不希望变量被子Makefile调用时，则使用unexport
   3. MAKEFLAGS变量在整个uboot中均使用(除非使用了unexport声明)
   4. 例子:
   ```Makefile
    MAKEFLAGS += -rR --include-dir=$(CURDIR)
    # += : 给MAKEFLAGS追加内容
    # -rR: 禁止使用内置的隐含规则和变量定义
    # --include-dir: 指明搜索路径
    # $(CURDIR)： 当前目录
   ```

3. 命令输入
   1. 在makefile中，语句`ifeq ("$(origin O)", "command line")`用于判断命令`O`是否来自于命令行
   2. 语句`$(shell mkdir -p $(KBUILD_OUTPUT))`用于执行shell命令
   3. make V=1:打印编译语句
   4. make -s:静默输出，不打印编译语句

4. 设置编译结果输出目录
   1. make O=out, out是用来把编译结果文件(.o等)输出到文件夹out中

5. 代码检查
   1. make C=1:使能代码检查，检查需要重新编译的代码
   2. make C=2:用于检查所有的源码文件
   3. C=1/C=2其实就是类似于IDE的编译和重新编译功能
   
6. 模块编译
   1. make M=dir:编译单独某个模块
   2. 如果M=null，全部编译
   3. 如果M=dir，编译dir下面的原文件为模块文件.ko

7. 获取主机架构和系统
   ```Makefile
   # 执行uname -m,输出结果是x86_64
    HOSTARCH := $(shell uname -m | \
	sed -e s/i.86/x86/ \
	    -e s/sun4u/sparc64/ \
	    -e s/arm.*/arm/ \
	    -e s/sa110/arm/ \
	    -e s/ppc64/powerpc/ \
	    -e s/ppc/powerpc/ \
	    -e s/macppc/powerpc/\
	    -e s/sh.*/sh/)

    # 执行uname -s，输出结果是linux
    HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
	    sed -e 's/\(cygwin\).*/cygwin/')
   ```

8. 配置目标架构、交叉编译器、配置文件
   ```Makefile
    ifeq ($(HOSTARCH),$(ARCH))
    CROSS_COMPILE ?=
    endif

    # 主机架构和HOSTARCH不一致，需要指定架构和编译器
    ARCH ?= arm
    CROSS_COMPILE ?= arm-linux-gnueabihf-

    # .config默认是没有的，需要执行make xxx_deconfig生成
    # xxx_deconfig只是说明单板配置，而只有.config的参数才会影响实际Makefile
    KCONFIG_CONFIG	?= .config
   ```

9. 调用scripts/Kbuild.include
   1.  主 Makefile 会调用文件 scripts/Kbuild.include
   2.  该文件定义了很多主Makefile需要用到的变量
    ```c++
    scripts/Kbuild.include: ;
    include scripts/Kbuild.include
    ```

10. 变量的导出
    1.  变量`ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR`是在uboot根目录下的config.mk中定义，而实际值却从.config中获取，.config需要通过命令`make xxx_deconfig`获取
```Makefile
export VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION
export ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR
export CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC
export CPP AR NM LDR STRIP OBJCOPY OBJDUMP
export MAKE AWK PERL PYTHON
export HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS

export KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS
export KBUILD_CFLAGS KBUILD_AFLAGS    
```

11. make xxx_deconfig过程
```Makefile
version_h := include/generated/version_autogenerated.h
timestamp_h := include/generated/timestamp_autogenerated.h

no-dot-config-targets := clean clobber mrproper distclean \
			 help %docs check% coccicheck \
			 ubootversion backup

config-targets := 0
mixed-targets  := 0
dot-config     := 1

# 以下两个判断的作用是确定参数config-targets mixed-targets dot-config的值
# filter函数：把MAKECMDGOALS含有参数1的内容过滤掉
ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
		dot-config := 0
	endif
endif

# 由于make xxx_deconfig中，MAKECMDGOALS=xxx_deconfig,因此该判断成功
ifeq ($(KBUILD_EXTMOD),)
        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
                config-targets := 1
                ifneq ($(words $(MAKECMDGOALS)),1)
                        mixed-targets := 1
                endif
        endif
endif

...
ifeq ($(config-targets),1)
# ===========================================================================
# *config targets only - make sure prerequisites are updated, and descend
# in scripts/kconfig to make the *config target

KBUILD_DEFCONFIG := sandbox_defconfig
export KBUILD_DEFCONFIG KBUILD_KCONFIG

config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

# make xxx_deconfig匹配成功该目标
%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

else

...
# 目标：FORCE无任何依赖，作为其他目标依赖时，肯定执行
PHONY += FORCE
FORCE:

# scripts_basic：build在Kbuild.include中定义
# build := -f $(srctree)/scripts/Makefile.build obj
# 
PHONY += scripts_basic
scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
	$(Q)rm -f .tmp_quiet_recordmcount

# outputmakefile， KBUILD_SRC未定义，因此outputmakefile不执行
PHONY += outputmakefile
outputmakefile:
ifneq ($(KBUILD_SRC),)
	$(Q)ln -fsn $(srctree) source
	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
endif

###################################################################################################
%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
########################%config命令可以展开如下#####################################################
# make xxx_deconfig最终生成了如下指令
@make -f ./scripts/Makefile.build obj=scripts/basic                         # 由目标scripts_basic生成            
@make -f ./scripts/Makefile.build obj=scripts/Kconfig xxx_defconfig         # @可有可无

```

12. Makefile.build 脚本分析
    1.  目标scripts/basic的作用时编译处scripts/basic/fixdep这个软件
    2.  目标scripts/Kconfig会读取`scripts/kconfig/Makefile`的内容，从而会执行该Makefile中的`%_defconfig`目标,从而最终会生成
![make xxx_deconfig流程图](https://github.com/TimChanCHN/pictures/raw/master/imx6ul/uboot_make_xxx_deconfig.png)

13. make过程(uboot的编译过程)
    1.  在make的过程中，由于不会传入其他命令，因此在顶层makefile中，会直接执行目标all，目标all会依赖u-boot.bin，该结果则是依赖于其他依赖生成的。
    2.  查看顶层Makefile的流程，就是先找到一个目标，然后根据依赖查看而得，有些目标是直接依赖一些变量，类似于递归找到起始条件一样。
    3.  ![make命令流程](https://github.com/TimChanCHN/pictures/raw/master/imx6ul/make%E5%91%BD%E4%BB%A4%E6%B5%81%E7%A8%8B.png)

