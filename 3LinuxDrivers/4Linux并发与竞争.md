# Linux并发与竞争
## 1.并发与竞争
1. 并发
   1. 并发是指多个任务同时访问同一个共享资源
   2. 产生并发的原因：
      1. 多线程并发访问
      2. 抢占式并发访问，即调度程序可以在任意时刻抢占正在运行的线程从而运行其他线程
      3. 中断程序并发访问
      4. 多核(SMP)核间并发访问
2. 竞争
   1. 多个线程同时操作临界区就会存在竞争，即并发导致了竞争的产生
3. 避免竞争和并发的产生，以实现对数据的保护

## 2.原子操作
1. 原子操作是指编译器无法继续分割的操作，即一个任务的多条连续指令需要一起执行，不能被其他任务打断。
2. 原子操作只能对整型变量或位进行保护。
3. 在C语言中，一个简单的赋值语言，编译成汇编语言后却不止一条指令，因此当多个任务对同一个变量赋值时，可能会出现并发，从而出现不一样的结果。
4. 原子整型操作API
   1. 如果要使用原子整型操作API函数，需要先定义一个atomic_t变量，原子操作会对该原子类型数据进行操作，该类型数据等同于整型数据
   2. 相关API
5. 原子位操作API


## 3.自旋锁
1. 自旋锁是指当线程要访问共享资源时，为保护共享资源，需要先申请自旋锁，自旋锁是表示资源有无被其他线程占用的标志，如果共享资源被其他线程占用，线程只能处于自旋状态，循环等待资源被释放。
2. 自旋锁适用于短时期的轻量级加锁，如果自旋锁持有时间太长，线程一直循环等待，浪费CPU资源。
3. 使用自旋锁
   1. Linux内核使用结构体`spinlock_t`表示自旋锁，内核使用自旋锁需要先申请一个自旋锁变量
   2. 自旋锁API函数适用于SMP或支持抢占的单CPU下线程之间的并发访问
   3. 被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API函数，否则可能会导致死锁
      1. 自旋锁会自动禁止抢占，如果线程A在持锁期间进入了休眠，则放弃了CPU使用权，
      2. 此时CPU使用权交给了线程B，如果线程B也希望获取锁，但是锁被线程A抢占，因此死锁发生。
   4. 中断可以获取自旋锁
      1. 如果线程A在获得自旋锁的过程中出发了中断B，如果中断B也申请自旋锁，但是此时锁被线程A占有着，因此中断B则处于阻塞等待的过程中
      2. 因此线程在获取自旋锁前需要关闭中断
        [线程与中断并发访问处理API函数]()
    5. 底半部也可以使用自旋锁
        [下半部竞争处理函数]()
4. 其他类型的锁
   1. 读写自旋锁`rwlock_t`
      1. 对于一些共享数据，写的时候只允许一个线程操作，但读的时候可以多个线程一起读
      2. 一个线程持有写锁时，所有线程都不能读
      3. 当写锁被释放了，可以允许多个线程持有读锁并发读操作
   2. 顺序锁`seqlock_t`
      1. 顺序锁由读写锁衍生，可以同时持有读写锁，但是如果读锁写锁两者同时发生，读锁最好重新读
      2. 顺序锁不允许并发的写操作
      3. 顺序锁不能保护指针资源
         1. 如果是指针资源，写操作可能会导致指针无效，如果同时有读操作访问指针，则可能会出现意外操作
5. 自旋锁注意事项
   1. 持锁时间必须要尽量短，不然会影响系统性能，如果临界区比较大，运行时间较长，则选择其他并发方式
   2. 保护的临界区不能有导致线程休眠/阻塞的操作，否则会导致死锁
   3. 不能递归申请自旋锁，如已经获得锁的状态下再申请锁
   4. 驱动编程时，为了考虑驱动的可移植性，都按照多核编写驱动程序

## 4.信号量
1. 信号量:本质上是一个计数器，假如一个信号量的初始值是10，意味着有10个线程可以同时访问临界资源。每当一个线程获得了信号量，则信号量值减1(P操作)，每当一个线程释放了信号量，则信号量值加1(V操作)。如果当信号量值减到0时，依然有新的线程想访问临界资源，则只能睡眠等待其他线程释放信号量，之后才能访问。
2. 二元信号量:只有0/1两个状态，其效果等同于互斥锁
3. 特点:
   1. 信号量可以使等待的线程进入休眠态，因此适用占用资源较久的场合；
   2. 信号量会引起休眠，因此中断中不能使用信号量；
   3. 若共享资源占用的时间较短，则不适用信号量，毕竟信号量会有切换的开销，频繁的切换引起的开销显得信号量并无优势
4. 信号量API
   1. 对结构体`struct semaphore`操作
   2. 

## 5.互斥体(mutex)
1. 互斥体表示一次只能由一个线程访问共享资源，就是二元信号量。不能递归申请互斥体，这样会引起死锁。
2. 互斥体的使用:
   1. 对结构体`struct mutex`操作
   2. mutex可以导致休眠，中断中不能使用mutex，中断中只能使用自旋锁
   3. 因为一次只有一个线程可以持有mutex，因此线程访问完共享资源后，必须由mutex的持有者释放mutex
3. 互斥体API
   1. 
